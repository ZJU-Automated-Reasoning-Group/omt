"""Search-based approach for Optimization Modulo Theory over
integers or reals
FIXME: to check (this file is generated by LLM)

- Markov Chain Monte Carlo (MCMC)
- Random sampling with simulated annealing
- Hill climbing with random restarts
- Genetic algorithm
- Particle Swarm Optimization (PSO)

The search space is characterized by SMT formulas, supporting both
real and integer variables.
"""

"""
Search-based optimization for Optimization Modulo Theory (OMT) problems.
The search space is characterized by SMT formulas, supporting both
real and integer variables.
"""

from dataclasses import dataclass
from enum import Enum, auto
from typing import Callable, Dict, List, Optional, Set, Tuple, Union
import random
import math
import time
from abc import ABC, abstractmethod

import z3

Number = Union[int, float]
SMTVar = Union[z3.Int, z3.Real]


class OptimizationType(Enum):
    MINIMIZE = auto()
    MAXIMIZE = auto()


@dataclass
class SMTSearchSpace:
    """Search space defined by SMT constraints"""

    solver: z3.Solver
    variables: Dict[str, SMTVar]  # Map of variable names to SMT variables
    bounds: Dict[str, Tuple[Number, Number]]  # Map of variable names to bounds

    def __post_init__(self):
        self.dimensions = len(self.variables)
        self._add_bounds_constraints()

    def _add_bounds_constraints(self):
        """Add bounds as constraints to the solver"""
        for name, var in self.variables.items():
            lb, ub = self.bounds[name]
            self.solver.add(var >= lb)
            self.solver.add(var <= ub)

    def is_feasible(self, assignment: Dict[str, Number]) -> bool:
        """Check if an assignment satisfies all constraints"""
        solver_copy = self.solver.translate(z3.main_ctx())

        # Add assignment constraints
        for name, value in assignment.items():
            var = self.variables[name]
            solver_copy.add(var == value)

        return solver_copy.check() == z3.sat

    def get_random_feasible(self) -> Optional[Dict[str, Number]]:
        """Generate a random feasible solution"""
        MAX_ATTEMPTS = 100

        for _ in range(MAX_ATTEMPTS):
            # Generate random assignment
            assignment = {}
            for name, (lb, ub) in self.bounds.items():
                var = self.variables[name]
                if isinstance(var, z3.IntNumRef):
                    value = random.randint(int(lb), int(ub))
                else:
                    value = random.uniform(lb, ub)
                assignment[name] = value

            if self.is_feasible(assignment):
                return assignment

        return None

    def get_nearest_feasible(self, point: Dict[str, Number]) -> Optional[Dict[str, Number]]:
        """Find nearest feasible point using optimization"""
        optimizer = z3.Optimize()

        # Add original constraints
        optimizer.add(self.solver.assertions())

        # Create variables for new point
        new_vars = {name: type(var)('new_' + name)
                    for name, var in self.variables.items()}

        # Add bounds for new variables
        for name, (lb, ub) in self.bounds.items():
            optimizer.add(new_vars[name] >= lb)
            optimizer.add(new_vars[name] <= ub)

        # Minimize distance to original point
        distance = 0
        for name, var in new_vars.items():
            distance += (var - point[name]) * (var - point[name])
        optimizer.minimize(distance)

        if optimizer.check() == z3.sat:
            model = optimizer.model()
            return {name: float(model[var].as_decimal(10).rstrip('?'))
                    for name, var in new_vars.items()}
        return None


@dataclass
class SearchResult:
    """Optimization result"""
    best_solution: Dict[str, Number]
    best_value: Number
    history: List[Tuple[Dict[str, Number], Number]]
    iterations: int
    time_taken: float


class SMTOptimizer(ABC):
    """Base class for SMT-constrained optimization"""

    def __init__(self,
                 objective_fn: Callable[[Dict[str, Number]], Number],
                 search_space: SMTSearchSpace,
                 optimization_type: OptimizationType = OptimizationType.MINIMIZE):
        self.objective_fn = objective_fn
        self.search_space = search_space
        self.optimization_type = optimization_type
        self.best_solution = None
        self.best_value = float('inf') if optimization_type == OptimizationType.MINIMIZE else float('-inf')

    def _evaluate(self, solution: Dict[str, Number]) -> Number:
        """Evaluate solution with feasibility check"""
        if not self.search_space.is_feasible(solution):
            return float('inf') if self.optimization_type == OptimizationType.MINIMIZE else float('-inf')

        value = self.objective_fn(solution)
        return value if self.optimization_type == OptimizationType.MINIMIZE else -value

    def _is_better(self, new_value: Number, old_value: Number) -> bool:
        """Compare values according to optimization type"""
        if self.optimization_type == OptimizationType.MINIMIZE:
            return new_value < old_value
        return new_value > old_value

    @abstractmethod
    def optimize(self, max_iterations: int = 1000) -> SearchResult:
        """Run the optimization algorithm"""
        pass


class SMTAdaptiveMCMC(SMTOptimizer):
    """MCMC optimization with adaptive step sizes and SMT constraints"""

    def __init__(self,
                 objective_fn: Callable[[Dict[str, Number]], Number],
                 search_space: SMTSearchSpace,
                 initial_temp: float = 1.0,
                 cooling_rate: float = 0.95,
                 adaptation_rate: float = 0.1):
        super().__init__(objective_fn, search_space)
        self.temperature = initial_temp
        self.cooling_rate = cooling_rate
        self.adaptation_rate = adaptation_rate
        self.step_sizes = {name: (ub - lb) * 0.1
                           for name, (lb, ub) in search_space.bounds.items()}

    def _propose_neighbor(self, current: Dict[str, Number]) -> Dict[str, Number]:
        """Generate neighbor with adaptive step sizes"""
        neighbor = {}
        for name, value in current.items():
            var = self.search_space.variables[name]
            lb, ub = self.search_space.bounds[name]

            # Generate perturbation
            step = self.step_sizes[name] * self.temperature
            if isinstance(var, z3.IntNumRef):
                delta = random.randint(-int(step), int(step))
                new_value = min(max(value + delta, lb), ub)
                new_value = int(new_value)
            else:
                delta = random.gauss(0, step)
                new_value = min(max(value + delta, lb), ub)

            neighbor[name] = new_value

        # If not feasible, try to find nearest feasible point
        if not self.search_space.is_feasible(neighbor):
            feasible = self.search_space.get_nearest_feasible(neighbor)
            if feasible is not None:
                neighbor = feasible

        return neighbor

    def _adapt_step_sizes(self, acceptance_rate: float):
        """Adapt step sizes based on acceptance rate"""
        target_rate = 0.234  # Optimal acceptance rate for many-dimensional problems

        for name in self.step_sizes:
            if acceptance_rate > target_rate:
                self.step_sizes[name] *= (1 + self.adaptation_rate)
            else:
                self.step_sizes[name] *= (1 - self.adaptation_rate)

    def optimize(self, max_iterations: int = 1000) -> SearchResult:
        start_time = time.time()

        # Get initial feasible solution
        current = self.search_space.get_random_feasible()
        if current is None:
            raise ValueError("Could not find initial feasible solution")

        current_value = self._evaluate(current)
        self.best_solution = current.copy()
        self.best_value = current_value

        history = [(current, current_value)]
        accepted = 0

        for i in range(max_iterations):
            neighbor = self._propose_neighbor(current)
            neighbor_value = self._evaluate(neighbor)

            # Accept based on Metropolis criterion
            delta = neighbor_value - current_value
            if delta < 0 or random.random() < math.exp(-delta / self.temperature):
                current = neighbor
                current_value = neighbor_value
                accepted += 1

                if self._is_better(current_value, self.best_value):
                    self.best_solution = current.copy()
                    self.best_value = current_value

            # Adapt step sizes every 100 iterations
            if (i + 1) % 100 == 0:
                acceptance_rate = accepted / 100
                self._adapt_step_sizes(acceptance_rate)
                accepted = 0

            history.append((current, current_value))
            self.temperature *= self.cooling_rate

        return SearchResult(
            best_solution=self.best_solution,
            best_value=self.best_value if self.optimization_type == OptimizationType.MINIMIZE
            else -self.best_value,
            history=history,
            iterations=max_iterations,
            time_taken=time.time() - start_time
        )


def example_usage():
    """Example usage with SMT constraints"""

    # Create solver and variables
    solver = z3.Solver()
    x = z3.Real('x')
    y = z3.Real('y')

    # Add SMT constraints
    solver.add(x + y <= 5)
    solver.add(x >= 0)
    solver.add(y >= 0)
    # solver.add(2 * x - y >= 1)

    # Define search space
    search_space = SMTSearchSpace(
        solver=solver,
        variables={'x': x, 'y': y},
        bounds={'x': (0, 10), 'y': (0, 10)}
    )

    # Objective function
    def objective(solution: Dict[str, Number]) -> Number:
        x_val, y_val = solution['x'], solution['y']
        return (x_val - 2) ** 2 + (y_val - 1) ** 2

    # Create and run optimizer
    optimizer = SMTAdaptiveMCMC(
        objective_fn=objective,
        search_space=search_space,
        initial_temp=1.0
    )
    print("start searching")

    result = optimizer.optimize(max_iterations=20)

    print("Optimization Results:")
    print(f"Best solution: {result.best_solution}")
    print(f"Best value: {result.best_value}")
    print(f"Time taken: {result.time_taken:.2f} seconds")


if __name__ == "__main__":
    example_usage()